<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" href="style.css">
</head>

<body>
<div class="main-body">
		<nav id="navbar">
			<header>Documentation Menu</header>
			<a href="#Intro" class="nav-link">
				What is C++</a>
			<a href="#Object" class="nav-link">
				Objects and Classes</a>
<a href="#Constructors" class="nav-link"> 
Constructors</a>

			<a href="#Inheritance" class="nav-link">
				Inheritance</a>
			<a href="#Polymorphism" class="nav-link">
				Polymorphism</a>
			<a href="#Abstraction" class="nav-link">
				Abstraction</a>
			<a href="#Encapsulation" class="nav-link">
				Encapsulation</a>
		</nav>

		<main id="main-doc">
			<section class="main-section" id="Intro">
				<header>
					What is C++?
				</header>
				<p>
					C++ is a general purpose programming
					language and widely used now a days '
					for competitive programming. It has
					imperative, object-oriented and generic
					programming features. C++ runs on lots of
					platform like Windows, Linux, Unix, Mac etc.
					C++ is an efficient
					and powerful language and finds wide use
					in various GUI platforms, 3D graphics and
					real-time simulations. Because of the
					inclusion of rich function libraries,
					working in C++ becomes simpler and
					convenient than C. Being object-oriented
					programming like Java, C++ provides
					the support of inheritance, polymorphism,
					encapsulation, etc. Unlike C, C++ allows
					exception handling and function overloading.
				</p>
				<p>The “Hello World” program is the first
					step towards learning any programming
					language and also one of the simplest
					programs you will learn. All you have
					to do is display the message “Hello World”
					on the screen.
					<br>Let us now look at the program :<br>
				</p>

      
   
<pre>
				<code>
#include&lt;iostream.h&gt;
using namespace std;
int main()
{
    cout<<"Hello World";
    return 0;
}
</code>
</pre>

				<p>C++ is an Object Oriented Programming Language.
					<br> The main pillars of Object Oriented
					Programming are :
				</p>
				<ul>
					<li>Objects and Classes</li>
					<li>Inheritance</li>
					<li>Polymorphism</li>
					<li>Abstraction</li>
					<li>Encapsulation</li>
				</ul>
			</section>

			<section class="main-section" id="Object">
				<h1>
					Objects and Classes
</h1>
				
				<p>
					Object-oriented programming – As the name
					suggests uses objects in programming.
					Object-oriented programming aims to
					implement real-world entities like
					inheritance, hiding, polymorphism,
					etc in programming. The main
					aim of OOP is to bind together the data
					and the functions that operate on them
					so that no other part of the code can
					access this data except that function.
				</p>
				<p><b>Object : </b>An Object is an identifiable
					entity with some characteristics and behavior.
					An Object is an instance of a Class. When a
					class is defined, no memory is allocated but
					when it is instantiated (i.e. an
					object is created) memory is allocated.
					<br>
					<b>Class : </b>The building block of C++ that
					leads to Object-Oriented programming is a Class.
					It is a user-defined data type, which holds its
					own data members and member functions, which can
					be accessed & used by creating an instance
					of that class. A class is like a blueprint for
					an object. For Example: Consider the Class
					of Cars. There may be many cars with different
					names and brand but all of them will share
					some common properties like all of them will
					have 4 wheels, Speed Limit, Mileage range etc.
					So here, Car is the class and wheels,
					speed limits, mileage are their properties.
				</p>
			</section>
<section class="main-section" id="Constructors">
				<header>Constructors</header>
				<p>
					A constructor is a special member function
					whose task is to initialize the objects of
					its class. It is special because its name is
					the same name as the class name. The
					constructor is invoked whenever an object of
					its associated class is created. It is called
					constructor because it constructs.
				</p>
				<p><b>Types of Constructors in C++ :</b></p>
				<p>
					<b>Default Constructor:</b> A constructor
					that accepts no parameters is called the
					default constructor.
					<br>Let us now look at the program:<br>
				</p>
<pre>
				<code>
#include&lt;iostream.h&gt;
using namespace std;
class item 
{
    int m, n;
public:
item()
{
    m = 10;
    n = 20;
}
    void put();
};
void item::put()
{
    cout << m << n;
}
void main() 
{
    item t;
    t.put();

}
				</code>
</pre>
				<p>
					<b>Parameterized Constructors:</b> The
					constructors that take parameters are called
					parameterized constructors.
					<br>Let us now look at the program:<br>
				</p>
<pre>
				<code>
#include&lt;iostream.h&gt;
using namespace std;
class item 
{
    int m, n;

public: 					
  item(int x, int y) 
  {
     m = x;
     n = y;					     
  }
  void put();
};					
  void item::put() 
  {
    cout << m << n;
  }
  void main() 
  {
    item t1(10, 20);
    item t2=item(20, 30);
    t1.put();
    t2.put();
  }
				</code>
</pre>
                      <p>
                            <b>Copy Constructor:</b>A copy constructor is used to declare and initialize an object from another object.
                             <br>Let us now look at the program:<br>
                           </p>
<pre>
<code>
#include&lt;iostream.h&gt; 
using namespace std;
class Sample 
{
    int id;

public:
    void init(int x) 
	{ 
       id = x;
    }
    void display()
	{ 
    cout <<"ID=" << id;
    }
};
int main()
{
    Sample obj1;
    obj1.init(10);
    obj1.display();
    Sample obj2(obj1);
    obj2.display();
    return 0;
}
Output:
Id=10
</code> 
</pre>
</section>
           <section class="main-section" id="Inheritance">
				<header>
					Inheritance
				</header>
				<p>
					The capability of a class to derive
					properties and characteristics from
					another class is called Inheritance.
					Inheritance is one of the most important
					feature of Object Oriented Programming.
				.	Sub Class: The class that inherits
					properties from another class
					is called Sub class or Derived Class.
					Super Class: The class whose properties
					are inherited by sub class is called Base
					Class or Super class. Using inheritance, we
					have to write the functions only one time
					instead of three times as we
					have inherited rest of the three classes
					from base class(Vehicle).
				</p>
				<p>
					<b>Mode of Inheritance : </b><br><br>

					<b>Public Mode : </b>If we derive a sub
					class from a public base class. Then the
					public member of the base class will
					become public in the derived class and
					protected members of the base class
					will become protected in derived class.
					<br><br>
					<b>Protected Mode : </b>If we derive a
					sub class from a Protected base class.
					Then both public member and protected
					members of the base class will become
					protected in derived class.
					<br><br>
					<b>Private Mode : </b>If we derive a
					sub class from a Private base class.
					Then both public member and protected
					members of the base class will become
					Private in derived class.
					<br><br>
					<b>Types of Inheritance in C++ : </b>
					<br><br>
					<b>Single Inheritance :</b> In single
					inheritance, a class is allowed to inherit
					from only one class. i.e. one sub class
					is inherited by one base class only.
					<br>Let us now look at the program:<br>

<pre>
<code>

#include&lt;iostream.h&gt; 
using namespace std; 
class A
{
public:
    int a,b;

    void get()
   {
        cout<<"Enter First value;
        cin>>a;
        cout<<"\n"<<"Enter Second value";
        cin>>b;
   }
};
class B:public A
{
public:
   int c;

   void add()
   {

   }
};
   void B::add()
   {
      c=a+b;
      cout << c;
}
int main()
{
    B b;
    b.get();
    b.add();
    return 0;
}
Output:
Enter First value 1
Enter Second value 61
Sum is 62
</code>
</pre>
                                    <b>Multilevel Inheritance :</b> In this type of inheritance the derived class inherits from a class, 
                                    which in turn inherits from some other class. The Super class for one, is sub class for the other.
                                    <br>Let us now look at the program:<br>
<pre>
<code>
#include&lt;iostream.h&gt; 
class A
{
public:
   int a,b; 
   void get()
   {
       cout<<"Enter First value";
       cin>>a;
       cout<<"\n"<<"Enter Second value";
       cin>>b;
   }
};
class B:public A
{
public:
   int c;
   void add()
   {
      c=a*b;
   }
};
class C:public B
{
public:
   void show()
   {
       cout<< c;
   }
};
int main()
{
    C c;
    c.get();
    c.add();
    c.show();
    return 0;
}
Output:
Enter First value 5
Enter Second value 2
10
</code>
</pre>
<br><br>
					<b>Multiple Inheritance :</b>: In this type of inheritance 
					a single derived class may inherit from two or more 
					than two base classes.
					<br>Let us now look at the program:<br>
                    <pre>
                        <code>							
#include&lt;iostream.h&gt; 
using namespace std;
class Mammal 
{
public:
   Mammal()
   {
            cout << "Mammals can give direct birth."<<"\n";
   }
};
class WingedAnimal 
{
public:
    WingedAnimal()
	{
            cout << "Winged animal can flap."<<"\n";
    }
};
class Bat: public Mammal, public WingedAnimal
{

};
int main()
{
    Bat b1;
    return 0;
}
Output:
Mammals can give direct birth.
Winged animal can flap.
</code>
</pre>
					<b>Hieratical Inheritance :</b> In this
					type of inheritance, more than one sub
					class is inherited from a single base
					class i.e. more than one derived class
					is created from a single base class.
					<br>Let us now look at the program:<br>
<pre>
	<code>
#include&lt;iostream.h&gt; 
class A 
{
public:
    int a;
   void getnumber()
   {
        cout<<"Enter Number"; 
        cin>>a;
   }
};
class B : public A
{
public:
   void square()
   {
        getnumber(); 
        cout<<"\n"<<"Square of the number: "<<(a*a);
	}
};
class C :public A 
{
public:
    void cube()
	{
        getnumber(); 
        cout<<"\n"<<"Cube of the number: "<<(a*a*a);
    }
};
int main()
{
        B b1;
        b1.square();
        C c1; 
        c1.cube();
        return 0;
}
Enter Number: 2
Square of the number: 4
Cube of the number: 8
</code>
</pre>

					<b>Hybrid (Virtual) Inheritance :</b>
					Hybrid Inheritance is implemented by
					combining more than one type of
					inheritance.
					<br>Let us now look at the program:<br>
<pre>
<code>
#include&lt;iostream.h&gt;  
using namespace std;
class A
{
public:
    int x;
};
class B : public A
{
public:

    B()
	{
        x = 10;
    }
};
class C
{
public:
   int y;

   C() 
   {
        y = 4;
   }
};
class D : public B, public C 
{
public:
    void sum()
   {
        cout << "Sum= " << x + y;
   }
};
int main()
{
    D obj1; 
    obj1.sum();
    return 0;
}
Output:
Sum= 14 
</code>
					</pre>
					
				</p>
			</section>

			<section class="main-section" id="Polymorphism">
				<header>
					Polymorphism
				</header>
				
					The word polymorphism means having many
					forms. In simple words, we can define
					polymorphism as the ability of a message
					to be displayed in more than one form.
					A real-life example of polymorphism, a
					person at the same time can have
					different characteristics.
					Like a man at the same time is a father,
					a husband, an employee. So the same
					person posses different behavior in
					different situations. This is called
					polymorphism. Polymorphism is considered
					as one of the important features of Object
					Oriented Programming.
					<br><br>
					<b>In C++ polymorphism is mainly
						divided into two types:</b>
					<br>1.Compile time Polymorphism<br>
					2. Runtime Polymorphism
					<br>
				   <b>1.Compile time polymorphism:</b>The overloaded functions are invoked by 
				    matching the type and number of arguments. 
					This information is available at the compile time and, 
					therefore, compiler selects the appropriate function at the compile time. 
					It is achieved by function overloading and operator overloading 
					which is also known as static binding or early binding.This type of
					polymorphism is achieved by function
					overloading or operator overloading.
				<h4>A. Function Overloading</h4>When there are multiple functions with 
				the same name but different parameters, 
				then the functions are said to be overloaded, 
				hence this is known as Function Overloading.
			    Functions can be overloaded by changing the
				number of arguments or/and changing the type of arguments.
				In simple terms, it is a feature of object-oriented
				programming providing many functions that have the same
				name but distinct parameters when numerous tasks 
				are listed under one function name.
				<br>Let us now look at the program:<br>
				<pre>
					<code>
#include&lt;iostream.h&gt;  
using namespace std;
class Fun
{
public:

    void show(int x)
	{
        cout << "value of x is ";
    }
    void show(double x)
	{
        cout << "\n"<<"value of x is "<< x;
    }
    void show(int x, int y)
	{
        cout << "\n"<<"value of x and y is " << x << ", " << y;
    }
};
int main()
{
    Fun obj1;
    obj1.show(7);
    obj1.show(9.132);
    obj1.show(85, 64);
    return 0;
}
Output:
value of x is 7
value of x is 9.132
value of x and y is 85, 64
</code>
</pre>
<h4>B.Operator Overloading</h4>C++ has the ability to provide the operators with a special meaning 
for a data type, this ability is known as operator overloading. 
For example, we can make use of the addition operator (+) 
for string class to concatenate two strings. We know that the task 
of this operator is to add two operands. So a single operator ‘+’, 
when placed between integer operands, adds them and when 
placed between string operands, concatenates them.
<br>Let us now look at the program:<br>
<pre>
	<code>
#include&lt;iostream.h&gt; 
using namespace std;
class A
{
public:
    A()
    int  value=5

    void operator ++ () 
	{
        ++value;
    }

    void show()
	{
        cout << "value: "<< value;
    }
};
int main() 
{
    A obj1;
    ++obj1;
    obj1.show();
    return 0;
}	
	</code>
</pre>
<br><br>

                       <b>2.Runtime polymorphism: </b>This type of polymorphism is achieved by Function Overriding.
                        Late binding and dynamic polymorphism are other names for runtime polymorphism.
						The function call is resolved at runtime in runtime polymorphism. 
						In contrast, with compile time polymorphism, the compiler determines which function 
						call to bind to the object after deducing it at runtime
						<br>
						<h4>A. Function Overriding</h4>Function Overriding occurs when a derived class 
						has a definition for one of the member functions of the base class. 
						That base function is said to be overridden.
						<br>Let us now look at the program:<br>
<pre>
	<code>
#include&lt;iostream.h&gt; 
using namespace std;
class Base
{
public:
   void display()
   {
        cout<<"\n"<<"Display Base";
   }
   virtual void show()
   {
        cout<<"\n"<<"Show Base";
   }
};
class Derived : public Base
{
public:
   void display()
   {
        cout<<"\n"<<"Display Derived";
   }
   void show()
   {
        cout<<"\n"<<"show derived";
   }
};
int  main()
{
    Base b;
    Derived d;
    Base *ptr;
    cout<<"\n"<<"ptr points to Base"; 
    ptr=&b;
    ptr->display();  
    ptr->show();
    cout<<"\n"<<"ptr points to derived"; 
    ptr=&d;
   ptr->display();  
   ptr->show();
   return 0;
}
Output:
ptr points to Base
Display Base
Show Base
ptr points to derived
Display Base
show derived
</code>
</pre>
<br><br>
<h4>B.Virtual Function</h4>A virtual function is a member function that is declared in the base class 
using the keyword virtual and is re-defined (Overridden) in the derived class.
<br>	
<b>Some Key Points About Virtual Functions:</b>
<br>
1.Virtual functions are Dynamic in nature.
<br>
2.They are defined by inserting the keyword “virtual” inside a base class and are always 
declared with a base class and overridden in a child class.
<br>
3.A virtual function is called during Runtime.
<br>Let us now look at the program:<br>
<pre>
	<code>
#include&lt;iostream.h&gt; 	
using namespace std;
class Base
{
public:
   void fun()
   {
        cout<<" Base class is called";
   }
};
class Derived:public Base
{
public:
   virtual void fun()
   {
        cout<<"Derived class is called";
   }
};
int main()
{
    Base b1;
    Derived d1;
    Base *ptr;
    ptr=&d1;
    ptr->fun();
    return 0;
}
Output:
Base class is called.
	</code>
</pre>	
</section>

			<section class="main-section" id="Abstraction">
				<header>
					Abstraction
				</header>

				<p>
					Data abstraction is one of the most
					essential and important feature of object
					oriented programming in C++. Abstraction
					means displaying only essential information
					and hiding the details. Data abstraction
					refers to providing only essential information
					about the data to the outside world,
					hiding the background details or implementation.
					<br> Consider a real life example of a man driving
					a car. The man only knows that pressing the
					accelerators will increase the speed of car
					or applying brakes will stop the car but he
					does not know about how on pressing accelerator
					the speed is actually increasing, he does
					not know about the inner mechanism of the car
					or the implementation of accelerator, brakes
					etc in the car. This is what abstraction is.
				</p>
				<p>
					<b>Abstraction using Classes:</b> We can
					implement Abstraction in C++ using classes.
					Class helps us to group data members and member
					functions using available access specifiers. A
					Class can decide which data member will be
					visible to outside
					world and which is not.
					<br>
					<b>Abstraction in Header files:</b> One
					more type of abstraction in C++ can be
					header files. For example, consider the
					pow() method present in math.h header file.
					Whenever we need to calculate power of a
					number, we simply call the
					function pow() present in the math.h header
					file and pass the numbers as arguments
					without knowing the underlying algorithm
					according to which the function is actually
					calculating power of numbers.
					<br><br><b>Advantages of Data Abstraction:

					</b><br> 1. Helps the user to avoid writing
					the low level code.<br> 2. Avoids code
					duplication and increases reusability.<br>
					3. Can change internal implementation of
					class independently without
					affecting the user.<br> 4. Helps to
					increase security of an application or program
					as only important details are
					provided to the user.
				<br>Let us now look at the program:<br>
				<pre>
					<code>

					
#include&lt;iostream.h&gt; 	
using namespace std;
class A
{
private:
   int a, b;
public:
    void set(int x, int y)
	{
	    a = x;
	    b = y;
    }
    void display()
	{
        cout << "a = " << a << "\n";
        cout << "b = " << b << "\n";
    }
};
int main()
{
    A obj;
    obj.set(10, 20);
    obj.display();
    return 0;
}
Output:
a = 10
b = 20
</code>
</pre>
</p>
			</section>

			<section class="main-section" id="Encapsulation">
				<header>
					Encapsulation
				</header>
				<p>
					In normal terms Encapsulation is defined
					as wrapping up of data and information
					under a single unit. In Object Oriented
					Programming, Encapsulation is defined as
					binding together the data and the functions
					that manipulates them. Consider
					a real life example
					of encapsulation, in a company there are
					different sections like the accounts section,
					finance section, sales section etc. The finance
					section handles all the financial transactions
					and keep records of all the data related to
					finance.
					Similarly the sales section handles all the
					sales related activities and keep records of
					all the sales. Now there may arise a situation
					when for some reason an official from finance
					section needs all the data about sales in a
					particular
					month. In this case, he is not allowed to
					directly access the data of sales section.
					He will first have to contact some other
					officer in the sales section and then
					request him to
					give the particular data. This is what
					encapsulation is. Here the data of
					sales section and the
					employees that can manipulate them are
					wrapped under a single name “sales section”.
				</p>

				<p>
					Encapsulation also lead to data abstraction
					or hiding. As using encapsulation also hides
					the data. In the above example the data of
					any of the section like sales, finance or
					accounts is hidden from any other section.<br>
					In C++ encapsulation
					can be implemented using Class
					and access modifiers.
				</p>
			<br>Let us now look at the program:<br>
			<pre>
				<code>
#include&lt;iostream.h&gt; 
using namespace std;
class Rectangle 
{
public:
   int length;
   int breadth;
Rectangle(int len, int brth)
{
    length=len;
    breadth=brth;
}
int getArea() 
{
    return length * breadth;
}
};
int main() 
{
    Rectangle rect(8, 6);
    cout << "Area = " << rect.getArea();
    return 0;
}
Output:
Area = 48
				</code>
			</pre>
				
			</section>

		</main>
</div>

	
</body>
</html>
